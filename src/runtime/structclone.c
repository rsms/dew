#include "structclone.h"


enum SCTag {
    SCTag_CHUNK,

    SCTag_NIL,
    SCTag_BOOL_FALSE,
    SCTag_BOOL_TRUE,
    SCTag_INTZ, // small integer embedded in tag, where value fits in 8-SCTagBits bits
    SCTag_INT,  // 8-byte integer
    SCTag_FLOAT,
    SCTag_STRZ, // small null-terminated string, useful with Lua's string cache
    SCTag_STRL, // large string with 4-byte size prefix; up to 4.0 GiB
    SCTag_ARRAY,
    SCTag_DICT,
    SCTag_FUN,

    SCTag_REF1, // reference to an already-serialized value (u8)
    SCTag_REF2, // reference to an already-serialized value (u16)
    SCTag_REF4, // reference to an already-serialized value (u32)

    // SCTag_BUF, // transfer a buffer

    SCTag_MAX = SCTag_REF4
};

#define SCTagBits 4
#define SCTagMask (((u8)1 << SCTagBits) - 1)

#define INTZ_SHIFT SCTagBits
#define INTZ_MAX   (((u8)1 << (8 - SCTagBits)) - 1)

static_assert((u32)1 << SCTagBits > (u32)SCTag_MAX, "SCTagBits too small for SCTag_MAX");

// REFTAB_IDX: stack index the reftab lives at
#define REFTAB_IDX 1


typedef struct Encoder {
    Buf*  buf;
    usize buf_startoffs;
    bool  has_reftab;
    int   err_no;
} Encoder;

typedef struct Decoder {
    const u8* buf;
    const u8* bufend;
    int       err_no;
    u32       ref_offs; // current chunk's start offset into buf->bytes

    #ifdef DEBUG
    const u8* bufstart;
    #endif
} Decoder;

static u8 g_reftabkey;


// dew_lua_arraylen returns the length of an array-optimized table, or U32_MAX if not an array.
// This function only works correctly for "strict" Lua tables as generated by dawn.
// I.e. either either strictly arrays '{1, "two"}' or dicts '{x=1, y="two"}'.
// It does NOT work correctly for mixed Lua tables like '{1, [2]="two"}'.
LUA_API lua_Unsigned dew_lua_arraylen(lua_State *L, int idx); // lapi.c

static void encode_value(lua_State *L, Encoder* enc, int vi);
static void decode_value(lua_State *L, Decoder* dec);


static const char* SCTagStr(u8 tag) {
    switch((enum SCTag)tag) {
        case SCTag_CHUNK:      return "CHUNK";
        case SCTag_NIL:        return "NIL";
        case SCTag_BOOL_FALSE: return "BOOL_FALSE";
        case SCTag_BOOL_TRUE:  return "BOOL_TRUE";
        case SCTag_INTZ:       return "INTZ";
        case SCTag_INT:        return "INT";
        case SCTag_FLOAT:      return "FLOAT";
        case SCTag_STRZ:       return "STRZ";
        case SCTag_STRL:       return "STRL";
        case SCTag_ARRAY:      return "ARRAY";
        case SCTag_DICT:       return "DICT";
        case SCTag_FUN:        return "FUN";
        case SCTag_REF1:       return "REF1";
        case SCTag_REF2:       return "REF2";
        case SCTag_REF4:       return "REF4";
    }
    static char buf[4];
    sprintf(buf, "?%02x", tag);
    return buf;
}


__attribute__((format(printf, 4, 5)))
static void _codec_error(lua_State *L, int* err_no_dst, int err_no, const char* fmt, ...) {
    assert(err_no > 0);
    *err_no_dst = -err_no;

    va_list argp;
    va_start(argp, fmt);
    luaL_where(L, 1);
    lua_pushvfstring(L, fmt, argp);
    va_end(argp);
    lua_concat(L, 2);
    lua_error(L);
}

#define codec_error(L, enc_or_dec, _err_no, fmt, ...) \
    ( (enc_or_dec)->err_no ? ((void)0) : \
      _codec_error(L, &(enc_or_dec)->err_no, _err_no, fmt, ##__VA_ARGS__) )


__attribute__((noinline))
static void enc_error_nomem(lua_State *L, Encoder* enc) {
    codec_error(L, enc, ENOMEM, "Cannot allocate memory");
}

__attribute__((noinline))
static void dec_error_short(lua_State *L, Decoder* dec) {
    codec_error(L, dec, EBADMSG, "Partial value");
}


static void enc_append_byte(lua_State *L, Encoder* enc, u8 byte) {
    if UNLIKELY(!buf_append_byte(enc->buf, byte))
        enc_error_nomem(L, enc);
}


static void enc_append(lua_State *L, Encoder* enc, const void* data, usize len) {
    if UNLIKELY(!buf_append(enc->buf, data, len))
        enc_error_nomem(L, enc);
}


static void encode_nil(lua_State *L, Encoder* enc, int vi) {
    enc_append_byte(L, enc, SCTag_NIL);
}

static void decode_nil(lua_State *L, Decoder* dec) {
    lua_pushnil(L);
    dec->buf++;
}


static void encode_bool(lua_State *L, Encoder* enc, int vi) {
    enc_append_byte(L, enc, lua_toboolean(L, vi) ? SCTag_BOOL_TRUE : SCTag_BOOL_FALSE);
}

static void decode_bool(lua_State *L, Decoder* dec) {
    lua_pushboolean(L, dec->buf[0] == SCTag_BOOL_TRUE);
    dec->buf++;
}


static void encode_number(lua_State *L, Encoder* enc, int vi) {
    int isint;
    lua_Integer vv = lua_tointegerx(L, vi, &isint);
    if (isint) {
        if (vv <= (lua_Integer)INTZ_MAX) {
            enc_append_byte(L, enc, SCTag_INTZ | ((u8)vv << INTZ_SHIFT));
        } else {
            enc_append_byte(L, enc, SCTag_INT);
            enc_append(L, enc, &vv, sizeof(vv));
        }
    } else {
        lua_Number vv = lua_tonumber(L, vi);
        enc_append_byte(L, enc, SCTag_FLOAT);
        enc_append(L, enc, &vv, sizeof(vv));
    }
}


static void decode_intz(lua_State *L, Decoder* dec) {
    lua_Integer n = (lua_Integer)(u64)((u8)dec->buf[0] >> INTZ_SHIFT);
    dec->buf++;
    lua_pushinteger(L, n);
}


static void decode_int(lua_State *L, Decoder* dec) {
    usize bufavail = dec->buf - dec->bufend;
    if UNLIKELY (bufavail < 1 + sizeof(lua_Integer))
        return dec_error_short(L, dec);
    lua_Integer n;
    memcpy(&n, &dec->buf[1], sizeof(lua_Integer));
    lua_pushinteger(L, n);
    dec->buf += 1 + sizeof(lua_Integer);
}


static void decode_float(lua_State *L, Decoder* dec) {
    usize bufavail = dec->buf - dec->bufend;
    if UNLIKELY (bufavail < 1 + sizeof(lua_Number))
        return dec_error_short(L, dec);
    lua_Number n;
    memcpy(&n, &dec->buf[1], sizeof(lua_Number));
    lua_pushnumber(L, n);
    dec->buf += 1 + sizeof(lua_Number);
}


static void encode_str(lua_State *L, Encoder* enc, int vi) {
    usize len;
    const char* ptr = lua_tolstring(L, vi, &len);
    if (len < 8 && memchr(ptr, 0, len) == NULL) {
        // small null-terminated string, encoded as exactly 8 bytes with zero padding
        u8* dst = buf_reserve(enc->buf, 8);
        if UNLIKELY(!dst)
            return enc_error_nomem(L, enc);
        memset(dst, 0, 8);
        dst[0] = SCTag_STRZ;
        memcpy(&dst[1], ptr, len);
        enc->buf->len += 8;
    } else if (len <= U32_MAX) {
        // length-prefixed string
        enc_append_byte(L, enc, SCTag_STRL);
        u32 lenv = (u32)len;
        enc_append(L, enc, &lenv, sizeof(lenv));
        enc_append(L, enc, ptr, len);
    } else {
        codec_error(L, enc, EMSGSIZE, "String too large");
    }
}

static void decode_strz(lua_State *L, Decoder* dec) {
    usize bufavail = dec->buf - dec->bufend;
    if UNLIKELY(bufavail < 8)
        return dec_error_short(L, dec);
    lua_pushstring(L, (char*)&dec->buf[1]);
    dec->buf += 8;
}

static void decode_str(lua_State *L, Decoder* dec) {
    usize bufavail = dec->buf - dec->bufend;
    // Smallest possible STRL is 6: { u8 tag, u32 len, u8 data[1] }.
    // Note that the encoder uses SCTag_STRZ for empty strings.
    if LIKELY(bufavail > 5) {
        u32 len;
        memcpy(&len, &dec->buf[1], sizeof(len));
        if LIKELY(bufavail >= 5 + len) {
            lua_pushlstring(L, (char*)&dec->buf[5], len);
            dec->buf += 5 + len;
            return;
        }
    }
    dec_error_short(L, dec);
}


static bool enc_ref_intern_ref(lua_State *L, Encoder* enc, int idx) {
    lua_Integer refval = lua_tointeger(L, -1);
    lua_pop(L, 1); // remove value from stack
    dlog("found ref at stream offset %lu", (u64)refval);
    if (refval <= 0xff) {
        u8 ref = (u8)refval;
        enc->buf->bytes[enc->buf->len] = SCTag_REF1;
        memcpy(&enc->buf->bytes[enc->buf->len + 1], &ref, sizeof(ref));
        enc->buf->len += 1 + sizeof(ref);
    } else if (refval <= 0xffff) {
        u16 ref = (u16)refval;
        enc->buf->bytes[enc->buf->len] = SCTag_REF2;
        memcpy(&enc->buf->bytes[enc->buf->len + 1], &ref, sizeof(ref));
        enc->buf->len += 1 + sizeof(ref);
    } else {
        u32 ref = (u32)refval;
        enc->buf->bytes[enc->buf->len] = SCTag_REF4;
        memcpy(&enc->buf->bytes[enc->buf->len + 1], &ref, sizeof(ref));
        enc->buf->len += 1 + sizeof(ref);
    }
    return false;
}


static bool enc_ref_intern(lua_State *L, Encoder* enc, int idx) {
    if (!enc->has_reftab) {
        // create "ref" table
        lua_createtable(L, 0, /*estimated common-case lowball count*/8);
        lua_rotate(L, 1, REFTAB_IDX); // move down into stack at REFTAB_IDX
        enc->has_reftab = true;
    } else {
        // look up
        // Push the key onto stack and then lookup key in reftab; push value onto stack.
        // lua_rawget returns the type of the value.
        lua_pushvalue(L, idx);
        int vtype = lua_rawget(L, REFTAB_IDX);
        if (vtype == LUA_TNUMBER)
            return enc_ref_intern_ref(L, enc, idx);
        lua_pop(L, 1); // remove value from stack (result from reftab[key])
    }
    // Add object: reftab[key] = value.
    // Push ref as value and object as key onto stack.
    u64 byte_offset = enc->buf->len - enc->buf_startoffs;
    dlog("registering ref at stream offset %lu", byte_offset);
    lua_pushvalue(L, idx); // key
    lua_pushinteger(L, (lua_Integer)byte_offset); // value
    lua_rawset(L, REFTAB_IDX); // reftab[key] = value
    return true;
}


static void encode_table(lua_State *L, Encoder* enc, int vi) {
    dlog_lua_stackf(L, "stack before encoding table");

    if UNLIKELY(!buf_reserve(enc->buf, 16))
        return enc_error_nomem(L, enc), ((void)0);

    if (!enc_ref_intern(L, enc, vi))
        return;

    u32 count = dew_lua_arraylen(L, -1);
    if (count != U32_MAX) {
        enc->buf->bytes[enc->buf->len++] = SCTag_ARRAY;
        memcpy(&enc->buf->bytes[enc->buf->len], &count, sizeof(u32));
        enc->buf->len += sizeof(u32);
        lua_pushnil(L);
        while (lua_next(L, -2) != 0) {
            encode_value(L, enc, -1);
            lua_pop(L, 1);
        }
    } else {
        enc->buf->bytes[enc->buf->len++] = SCTag_DICT;
        usize count_bufoff = enc->buf->len;
        enc->buf->len += sizeof(u32); // allocate space for count
        count = 0;
        lua_pushnil(L);
        while (lua_next(L, -2) != 0) {
            encode_value(L, enc, -2); // key
            encode_value(L, enc, -1); // value
            lua_pop(L, 1);
            count++;
        }
        memcpy(&enc->buf->bytes[count_bufoff], &count, sizeof(u32));
    }

    dlog_lua_stackf(L, "stack after encoding table");
}

static void decode_array(lua_State *L, Decoder* dec) {
    usize bufavail = dec->buf - dec->bufend;
    if UNLIKELY(bufavail < 5)
        return dec_error_short(L, dec);

    dlog("TODO: add ARRAY to reftab");
    // TODO: reftab[stream_offset] = stack_idx

    u32 count;
    memcpy(&count, dec->buf + 1, sizeof(count));
    dec->buf += 1 + sizeof(count); // tag + count

    lua_createtable(L, (int)MIN(count, (u32)I32_MAX), 0);
    // TODO: decode values
    for (u32 i = 1; i <= count && dec->err_no == 0; i++) {
        assertf(dec->buf < dec->bufend, "i=%u count=%u", i, count); // decode functions checks this
        lua_pushinteger(L, i); // key
        decode_value(L, dec); // value
        lua_rawset(L, -3); // table[key] = value
    }
}



static void encode_fun(lua_State *L, Encoder* enc, int vi) {
    enc_append_byte(L, enc, SCTag_FUN);
    codec_error(L, enc, ENOSYS, "TODO: encode function");
}


static void encode_value(lua_State *L, Encoder* enc, int vi) {
    int vt = lua_type(L, vi);
    fprintf(stderr, ">> [encode_value] "); dlog_lua_val(L, vi);
    switch (vt) {
        case LUA_TNIL:      return_tail encode_nil(L, enc, vi);
        case LUA_TBOOLEAN:  return_tail encode_bool(L, enc, vi);
        case LUA_TNUMBER:   return_tail encode_number(L, enc, vi);
        case LUA_TSTRING:   return_tail encode_str(L, enc, vi);
        case LUA_TTABLE:    return_tail encode_table(L, enc, vi);
        case LUA_TFUNCTION: return_tail encode_fun(L, enc, vi);
        // LUA_TLIGHTUSERDATA
        // LUA_TUSERDATA
        // LUA_TTHREAD
    }
    codec_error(L, enc, EINVAL, "Attempted to encode value of type %s", lua_typename(L, vt));
}


static void decode_value(lua_State *L, Decoder* dec) {
    assert(dec->buf < dec->bufend);
    dlog("decode %s", SCTagStr(dec->buf[0] & SCTagMask));
    switch ((enum SCTag)dec->buf[0] & SCTagMask) {
        case SCTag_NIL:        return_tail decode_nil(L, dec);
        case SCTag_BOOL_FALSE:
        case SCTag_BOOL_TRUE:  return_tail decode_bool(L, dec);
        case SCTag_INTZ:       return_tail decode_intz(L, dec);
        case SCTag_INT:        return_tail decode_int(L, dec);
        case SCTag_FLOAT:      return_tail decode_float(L, dec);
        case SCTag_STRZ:       return_tail decode_strz(L, dec);
        case SCTag_STRL:       return_tail decode_str(L, dec);
        case SCTag_ARRAY:      return_tail decode_array(L, dec);
        case SCTag_DICT:  dlog("TODO: decode DICT"); dec->buf = dec->bufend; return;
        case SCTag_FUN:   dlog("TODO: decode FUN"); dec->buf = dec->bufend; return;
        case SCTag_REF1:  dlog("TODO: decode REF1"); dec->buf = dec->bufend; return;
        case SCTag_REF2:  dlog("TODO: decode REF2"); dec->buf = dec->bufend; return;
        case SCTag_REF4:  dlog("TODO: decode REF4"); dec->buf = dec->bufend; return;
        case SCTag_CHUNK: break; // TODO: stop gracefully if this is encountered at top level
    }
    dlog("unexpected byte 0x%02x at offset %zu", dec->buf[0], (usize)(dec->buf - dec->bufstart));
    codec_error(L, dec, EINVAL, "Invalid encoded data");
}


int structclone_encode(lua_State* L, Buf* buf, int startarg, int nargs) {
    Encoder enc = { .buf = buf, .buf_startoffs = buf->len };

    // reserve some reasonable amount of space up front
    if UNLIKELY(!buf_reserve(buf, 128)) {
        enc_error_nomem(L, &enc);
        return enc.err_no;
    }

    // encode chunk header
    buf->bytes[buf->len++] = SCTag_CHUNK;

    // write values in stack order, i.e. arguments a, b, c are written c, b, a
    while (nargs-- > 0 && enc.err_no == 0) {
        encode_value(L, &enc, -1);
        lua_pop(L, 1);
    }

    // if we created a reftab, remove it
    if (enc.has_reftab)
        lua_remove(L, REFTAB_IDX);

    return enc.err_no;
}


int structclone_decode(lua_State* L, const void* buf, usize buflen) {
    if UNLIKELY(buflen < 1 || *(u8*)buf != SCTag_CHUNK)
        return luaL_error(L, "Invalid data");

    Decoder dec = { .buf = buf + 1, .bufend = buf + buflen };
    #ifdef DEBUG
    dec.bufstart = dec.buf;
    #endif

    int top_start = lua_gettop(L);
    int stack_base = top_start+1;
    while (dec.buf < dec.bufend && dec.err_no == 0) {
        decode_value(L, &dec);
        lua_rotate(L, stack_base, 1); // TODO: this won't work for compound values
    }

    dlog_lua_stackf(L, "stack after decoding");
    return dec.err_no ? dec.err_no : lua_gettop(L) - top_start;
}
